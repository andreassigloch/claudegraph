{% extends "base.html" %}

{% block title %}Graph Viewer - {{ super() }}{% endblock %}

{% block extra_head %}
<style>
    .upload-area {
        text-align: center;
        padding: 60px 30px;
        border: 3px dashed #ddd;
        margin: 30px 0;
        border-radius: 12px;
        transition: all 0.3s ease;
        cursor: pointer;
        background: #f8f9fa;
    }

    .upload-area:hover, .upload-area.dragover {
        border-color: #0d6efd;
        background: #e7f3ff;
    }

    .upload-area h3 {
        color: #333;
        font-size: 1.8em;
        margin-bottom: 15px;
    }

    .upload-area p {
        color: #666;
        font-size: 1.1em;
        margin-bottom: 25px;
    }

    .results {
        display: none;
    }

    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    .stat {
        background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%);
        padding: 25px;
        border-radius: 12px;
        text-align: center;
        border: 1px solid #e1e8ff;
    }

    .stat h4 {
        color: #0d6efd;
        font-size: 0.9em;
        text-transform: uppercase;
        margin-bottom: 10px;
        font-weight: 600;
    }

    .stat span {
        font-size: 2.5em;
        font-weight: bold;
        color: #333;
    }

    .network-container {
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #fafafa;
        margin-top: 15px;
        min-height: 600px;
    }

    .legend {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        border: 1px solid #dee2e6;
    }

    .legend-title {
        font-weight: 600;
        margin-bottom: 10px;
        color: #333;
    }

    .legend-items {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9em;
    }

    .legend-line {
        width: 20px;
        height: 2px;
    }

    .legend-circle {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 2px solid #fff;
    }

    #projectInfo {
        background: #f8f9ff;
        padding: 20px;
        border-radius: 8px;
        border-left: 4px solid #0d6efd;
    }

    #projectInfo h3 {
        color: #0d6efd;
        margin-bottom: 15px;
    }

    .error-message {
        background: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
        border-left: 4px solid #f5c6cb;
    }

    .analysis-controls {
        background: #e7f3ff;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        border-left: 4px solid #0d6efd;
    }

    .progress-container {
        display: none;
        margin: 20px 0;
    }

    .progress {
        height: 25px;
        background-color: #e9ecef;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .progress-bar {
        background: linear-gradient(135deg, #0d6efd 0%, #6f42c1 100%);
        transition: width 0.3s ease;
        height: 100%;
        border-radius: 15px;
    }

    .progress-text {
        margin: 10px 0;
        color: #666;
        font-weight: 500;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1><i class="bi bi-diagram-3"></i> Graph Analyzer Viewer</h1>
            <div>
                <span class="badge bg-info">Integrated Viewer</span>
            </div>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <h3>Graph Visualization</h3>
            <p>Upload a JSON analysis file to visualize the architectural graph</p>
            <input type="file" id="fileInput" accept=".json" style="display: none;">
            <button class="btn btn-primary btn-lg" onclick="document.getElementById('fileInput').click()">
                <i class="bi bi-file-earmark-arrow-up"></i> Choose JSON File
            </button>
            
            <div class="mt-4">
                <p class="text-muted">
                    <i class="bi bi-info-circle"></i>
                    To analyze a new project, use the <a href="/analyzer" class="text-decoration-none">Project Analyzer</a> first.
                </p>
            </div>
        </div>

        <div id="results" class="results">
            <!-- Tabs -->
            <ul class="nav nav-tabs" id="resultTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="overview-tab" data-bs-toggle="tab" data-bs-target="#overview" type="button" role="tab">
                        <i class="bi bi-info-circle"></i> Overview
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="network-tab" data-bs-toggle="tab" data-bs-target="#network" type="button" role="tab">
                        <i class="bi bi-diagram-3"></i> Full Network
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="flow-tab" data-bs-toggle="tab" data-bs-target="#flow" type="button" role="tab">
                        <i class="bi bi-arrow-right-circle"></i> Flow View
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="nodes-tab" data-bs-toggle="tab" data-bs-target="#nodes" type="button" role="tab">
                        <i class="bi bi-circle"></i> Nodes
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="relationships-tab" data-bs-toggle="tab" data-bs-target="#relationships" type="button" role="tab">
                        <i class="bi bi-arrow-left-right"></i> Relationships
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="raw-tab" data-bs-toggle="tab" data-bs-target="#raw" type="button" role="tab">
                        <i class="bi bi-code"></i> Raw Data
                    </button>
                </li>
            </ul>

            <div class="tab-content" id="resultTabsContent">
                <!-- Overview Tab -->
                <div class="tab-pane fade show active" id="overview" role="tabpanel">
                    <div class="p-4">
                        <div class="stats">
                            <div class="stat">
                                <h4>Nodes</h4>
                                <span id="totalNodes">0</span>
                            </div>
                            <div class="stat">
                                <h4>Relationships</h4>
                                <span id="totalRelationships">0</span>
                            </div>
                            <div class="stat">
                                <h4>Files</h4>
                                <span id="filesAnalyzed">0</span>
                            </div>
                            <div class="stat">
                                <h4>Functions</h4>
                                <span id="functionsFound">0</span>
                            </div>
                        </div>
                        <div id="projectInfo"></div>
                    </div>
                </div>

                <!-- Network Tab -->
                <div class="tab-pane fade" id="network" role="tabpanel">
                    <div class="p-4">
                        <div class="mb-3">
                            <button class="btn btn-outline-primary" id="resetZoom">
                                <i class="bi bi-zoom-out"></i> Reset Zoom
                            </button>
                            <button class="btn btn-outline-secondary" id="toggleLabels">
                                <i class="bi bi-tag"></i> Toggle Labels
                            </button>
                            <select id="layoutSelect" class="form-select d-inline-block" style="width: auto; margin-left: 10px;">
                                <option value="force">Force Layout</option>
                                <option value="tree">Tree Layout</option>
                                <option value="cluster">Cluster Layout</option>
                                <option value="partition">Partition Layout</option>
                                <option value="sankey">Sankey Layout</option>
                            </select>
                        </div>
                        
                        <div class="legend">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-items">
                                <div class="legend-item">
                                    <div class="legend-circle" style="background: #dc3545;"></div>
                                    SYS (Systems)
                                </div>
                                <div class="legend-item">
                                    <div class="legend-circle" style="background: #20c997;"></div>
                                    MOD (Modules)
                                </div>
                                <div class="legend-item">
                                    <div class="legend-circle" style="background: #0dcaf0;"></div>
                                    FUNC (Functions)
                                </div>
                                <div class="legend-item">
                                    <div class="legend-circle" style="background: #198754;"></div>
                                    ACTOR (External)
                                </div>
                            </div>
                        </div>
                        
                        <div class="legend">
                            <div class="legend-title">Connection Types</div>
                            <div class="legend-items">
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #0d6efd;"></div>
                                    compose
                                </div>
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #fd7e14;"></div>
                                    call
                                </div>
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #198754;"></div>
                                    use
                                </div>
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #d63384;"></div>
                                    flow
                                </div>
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #6f42c1;"></div>
                                    allocate
                                </div>
                            </div>
                        </div>
                        
                        <div id="networkView" class="network-container"></div>
                    </div>
                </div>

                <!-- Flow Tab -->
                <div class="tab-pane fade" id="flow" role="tabpanel">
                    <div class="p-4">
                        <div class="mb-3">
                            <button class="btn btn-outline-primary" id="resetZoomFlow">
                                <i class="bi bi-zoom-out"></i> Reset Zoom
                            </button>
                            <button class="btn btn-outline-secondary" id="toggleLabelsFlow">
                                <i class="bi bi-tag"></i> Toggle Labels
                            </button>
                            <select id="layoutSelectFlow" class="form-select d-inline-block" style="width: auto; margin-left: 10px;">
                                <option value="force">Force Layout</option>
                                <option value="tree">Tree Layout</option>
                                <option value="cluster">Cluster Layout</option>
                                <option value="partition">Partition Layout</option>
                                <option value="sankey">Sankey Layout</option>
                            </select>
                        </div>
                        
                        <div class="legend">
                            <div class="legend-title">Flow Analysis View</div>
                            <div class="legend-items">
                                <div class="legend-item">
                                    <div class="legend-circle" style="background: #0dcaf0;"></div>
                                    FUNC (Functions)
                                </div>
                                <div class="legend-item">
                                    <div class="legend-circle" style="background: #198754;"></div>
                                    ACTOR (External)
                                </div>
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #d63384;"></div>
                                    flow connections
                                </div>
                            </div>
                        </div>
                        
                        <div id="flowView" class="network-container"></div>
                    </div>
                </div>

                <!-- Nodes Tab -->
                <div class="tab-pane fade" id="nodes" role="tabpanel">
                    <div class="p-4">
                        <div id="nodesTable"></div>
                    </div>
                </div>

                <!-- Relationships Tab -->
                <div class="tab-pane fade" id="relationships" role="tabpanel">
                    <div class="p-4">
                        <div id="relationshipsTable"></div>
                    </div>
                </div>

                <!-- Raw Data Tab -->
                <div class="tab-pane fade" id="raw" role="tabpanel">
                    <div class="p-4">
                        <pre id="rawData" class="bg-light p-3 rounded" style="max-height: 600px; overflow-y: auto;"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    let currentData = null;
    let labelsVisible = true;
    let labelsVisibleFlow = true;
    let currentLayout = 'force';
    let currentLayoutFlow = 'force';

    document.addEventListener('DOMContentLoaded', function() {
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        
        fileInput.addEventListener('change', handleFileSelect);
        
        // Drag and drop functionality
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        // Tab functionality for network/flow views
        document.getElementById('network-tab').addEventListener('click', () => {
            if (currentData) {
                setTimeout(() => createNetworkView(currentData), 100);
            }
        });

        document.getElementById('flow-tab').addEventListener('click', () => {
            if (currentData) {
                setTimeout(() => createFlowView(currentData), 100);
            }
        });

        // Network controls
        document.getElementById('resetZoom')?.addEventListener('click', () => {
            if (currentData) createNetworkView(currentData);
        });

        document.getElementById('toggleLabels')?.addEventListener('click', () => {
            labelsVisible = !labelsVisible;
            document.querySelectorAll('#networkView text').forEach(text => {
                text.style.display = labelsVisible ? 'block' : 'none';
            });
        });

        // Flow view controls
        document.getElementById('resetZoomFlow')?.addEventListener('click', () => {
            if (currentData) createFlowView(currentData);
        });

        document.getElementById('toggleLabelsFlow')?.addEventListener('click', () => {
            labelsVisibleFlow = !labelsVisibleFlow;
            document.querySelectorAll('#flowView text').forEach(text => {
                text.style.display = labelsVisibleFlow ? 'block' : 'none';
            });
        });

        // Layout selection
        document.getElementById('layoutSelect')?.addEventListener('change', (e) => {
            currentLayout = e.target.value;
            if (currentData) createNetworkView(currentData);
        });

        document.getElementById('layoutSelectFlow')?.addEventListener('change', (e) => {
            currentLayoutFlow = e.target.value;
            if (currentData) createFlowView(currentData);
        });

        // Check for stored analysis result from analyzer
        checkForStoredAnalysis();
    });

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            handleFile(file);
        }
    }


    function handleFile(file) {
        if (!file.name.endsWith('.json')) {
            showToast('Please select a JSON file.', 'error');
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                currentData = JSON.parse(e.target.result);
                showResults(currentData);
            } catch (error) {
                showToast('Error parsing JSON: ' + error.message, 'error');
            }
        };
        reader.readAsText(file);
    }

    function showResults(data) {
        if (!data.nodes || !data.relationships) {
            showToast('Invalid JSON format. Expected "nodes" and "relationships" arrays.', 'error');
            return;
        }

        document.getElementById('results').style.display = 'block';

        // Update statistics
        const stats = data.metadata?.analysis_stats || {};
        document.getElementById('totalNodes').textContent = data.nodes?.length || 0;
        document.getElementById('totalRelationships').textContent = data.relationships?.length || 0;
        document.getElementById('filesAnalyzed').textContent = stats.files_parsed || 0;
        document.getElementById('functionsFound').textContent = stats.functions_found || 0;

        // Project info
        let info = '<h3>Project Information</h3>';
        if (data.metadata) {
            info += '<p><strong>Path:</strong> ' + (data.metadata.project_path || 'Unknown') + '</p>';
            info += '<p><strong>Version:</strong> ' + (data.metadata.analysis_version || 'Unknown') + '</p>';
            if (data.metadata.timestamp) {
                info += '<p><strong>Analyzed:</strong> ' + new Date(data.metadata.timestamp).toLocaleString() + '</p>';
            }
        }
        document.getElementById('projectInfo').innerHTML = info;

        // Nodes table
        let html = '<table class="table table-striped"><thead><tr><th>Type</th><th>Name</th><th>Description</th><th>UUID</th></tr></thead><tbody>';
        data.nodes.forEach(node => {
            html += `<tr>
                <td><span class="badge bg-secondary">${node.type}</span></td>
                <td>${node.Name || 'N/A'}</td>
                <td>${node.Descr || 'N/A'}</td>
                <td><small class="text-muted">${node.uuid || 'N/A'}</small></td>
            </tr>`;
        });
        html += '</tbody></table>';
        document.getElementById('nodesTable').innerHTML = html;

        // Relationships table
        html = '<table class="table table-striped"><thead><tr><th>Type</th><th>Source</th><th>Target</th></tr></thead><tbody>';
        data.relationships.forEach(rel => {
            const source = data.nodes.find(n => n.uuid === rel.source);
            const target = data.nodes.find(n => n.uuid === rel.target);
            html += `<tr>
                <td><span class="badge bg-info">${rel.type}</span></td>
                <td>${source ? source.Name : 'Unknown'}</td>
                <td>${target ? target.Name : 'Unknown'}</td>
            </tr>`;
        });
        html += '</tbody></table>';
        document.getElementById('relationshipsTable').innerHTML = html;

        // Raw data
        document.getElementById('rawData').textContent = JSON.stringify(data, null, 2);

        showToast('Analysis results loaded successfully!', 'success');
    }

    // Check for analysis result from analyzer on page load
    function checkForStoredAnalysis() {
        console.log('checkForStoredAnalysis: Checking for stored analysis result...');
        
        // First check sessionStorage
        const storedResult = sessionStorage.getItem('analysisResult');
        console.log('checkForStoredAnalysis: sessionStorage result =', storedResult ? 'found' : 'not found');
        
        if (storedResult) {
            try {
                console.log('checkForStoredAnalysis: Parsing stored result...');
                const analysisData = JSON.parse(storedResult);
                console.log('checkForStoredAnalysis: Parsed data successfully, nodes:', analysisData.nodes?.length, 'relationships:', analysisData.relationships?.length);
                currentData = analysisData;
                showResults(analysisData);
                sessionStorage.removeItem('analysisResult'); // Clean up
                console.log('checkForStoredAnalysis: Successfully loaded analysis results from analyzer');
                showToast('Analysis results loaded from analyzer', 'success');
                return; // Exit early if successful
            } catch (error) {
                console.error('checkForStoredAnalysis: Failed to parse stored analysis result:', error);
                showToast('Failed to parse analysis results', 'error');
            }
        }
        
        // Check URL parameters as backup
        const urlParams = new URLSearchParams(window.location.search);
        const jobId = urlParams.get('job_id');
        console.log('checkForStoredAnalysis: URL job_id =', jobId || 'not found');
        
        if (jobId) {
            console.log('checkForStoredAnalysis: Attempting to fetch result for job:', jobId);
            fetch(`/api/result/${jobId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    console.log('checkForStoredAnalysis: Fetched data from job_id:', data);
                    currentData = data;
                    showResults(data);
                    showToast('Analysis results loaded from job ID', 'success');
                    // Clean up URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                })
                .catch(error => {
                    console.error('checkForStoredAnalysis: Failed to fetch result from job_id:', error);
                    showToast('Failed to load analysis results from job ID', 'error');
                });
            return;
        }
        
        console.log('checkForStoredAnalysis: No analysis result found in sessionStorage or URL');
    }

    // This function is now called from within DOMContentLoaded

    function createNetworkView(data) {
        const container = d3.select('#networkView');
        container.selectAll('*').remove();

        const width = 800, height = 600;
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);

        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        svg.call(zoom);
        const g = svg.append('g');

        // Choose layout based on selection
        switch(currentLayout) {
            case 'tree':
                createTreeLayout(svg, g, data, width, height, 'network');
                return;
            case 'cluster':
                createClusterLayout(svg, g, data, width, height, 'network');
                return;
            case 'partition':
                createPartitionLayout(svg, g, data, width, height, 'network');
                return;
            case 'sankey':
                createSankeyLayout(svg, g, data, width, height, 'network');
                return;
            default:
                // Continue with force layout
                break;
        }

        const nodes = data.nodes.map(d => ({
            id: d.uuid,
            name: d.Name || d.uuid?.substring(0, 8) || 'Unknown',
            type: d.type,
            description: d.Descr || ''
        }));

        const links = data.relationships.filter(rel => {
            return nodes.some(n => n.id === rel.source) && nodes.some(n => n.id === rel.target);
        }).map(d => ({
            source: d.source,
            target: d.target,
            type: d.type
        }));

        const nodeColors = {
            SYS: '#dc3545',
            MOD: '#20c997',
            FUNC: '#0dcaf0',
            ACTOR: '#198754'
        };

        const linkColors = {
            compose: '#0d6efd',
            call: '#fd7e14',
            use: '#198754',
            flow: '#d63384',
            allocate: '#6f42c1'
        };

        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width/2, height/2))
            .force('collision', d3.forceCollide().radius(20));

        // Links
        const link = g.append('g')
            .selectAll('line')
            .data(links)
            .enter()
            .append('line')
            .attr('stroke', d => linkColors[d.type] || '#999')
            .attr('stroke-width', 2)
            .attr('stroke-opacity', 0.7);

        // Nodes
        const node = g.append('g')
            .selectAll('circle')
            .data(nodes)
            .enter()
            .append('circle')
            .attr('r', 10)
            .attr('fill', d => nodeColors[d.type] || '#999')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        // Labels
        const labels = g.append('g')
            .selectAll('text')
            .data(nodes)
            .enter()
            .append('text')
            .text(d => d.name)
            .attr('font-size', 10)
            .attr('text-anchor', 'middle')
            .attr('dy', -15)
            .attr('fill', '#333')
            .style('pointer-events', 'none');

        // Tooltips
        node.append('title')
            .text(d => `${d.type}: ${d.name}\n${d.description}`);

        link.append('title')
            .text(d => `${d.type}: ${d.source.name || d.source.id} → ${d.target.name || d.target.id}`);

        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);

            labels
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }

    function createFlowView(data) {
        const container = d3.select('#flowView');
        container.selectAll('*').remove();

        const width = 800, height = 600;
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);

        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        svg.call(zoom);
        const g = svg.append('g');

        // Filter data for flow view
        const flowNodes = data.nodes.filter(d => d.type === 'FUNC' || d.type === 'ACTOR');
        const flowLinks = data.relationships.filter(rel => rel.type === 'flow');
        const flowData = { nodes: flowNodes, relationships: flowLinks };

        // Choose layout based on selection
        switch(currentLayoutFlow) {
            case 'tree':
                createTreeLayout(svg, g, flowData, width, height, 'flow');
                return;
            case 'cluster':
                createClusterLayout(svg, g, flowData, width, height, 'flow');
                return;
            case 'partition':
                createPartitionLayout(svg, g, flowData, width, height, 'flow');
                return;
            case 'sankey':
                createSankeyLayout(svg, g, flowData, width, height, 'flow');
                return;
            default:
                // Continue with force layout
                break;
        }

        // Filter to only FUNC and ACTOR nodes
        const flowNodesForce = data.nodes.filter(d => d.type === 'FUNC' || d.type === 'ACTOR').map(d => ({
            id: d.uuid,
            name: d.Name || d.uuid?.substring(0, 8) || 'Unknown',
            type: d.type,
            description: d.Descr || ''
        }));

        // Filter to only flow relationships
        const flowNodeIds = new Set(flowNodesForce.map(n => n.id));
        const flowLinksForce = data.relationships.filter(rel => {
            return rel.type === 'flow' && 
                   flowNodeIds.has(rel.source) && 
                   flowNodeIds.has(rel.target);
        }).map(d => ({
            source: d.source,
            target: d.target,
            type: d.type
        }));

        const nodeColors = {
            FUNC: '#0dcaf0',
            ACTOR: '#198754'
        };

        const simulation = d3.forceSimulation(flowNodesForce)
            .force('link', d3.forceLink(flowLinksForce).id(d => d.id).distance(150))
            .force('charge', d3.forceManyBody().strength(-400))
            .force('center', d3.forceCenter(width/2, height/2))
            .force('collision', d3.forceCollide().radius(25));

        // Add arrowhead marker
        svg.append('defs').append('marker')
            .attr('id', 'arrowhead-flow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 15)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#d63384');

        // Flow links
        const link = g.append('g')
            .selectAll('line')
            .data(flowLinksForce)
            .enter()
            .append('line')
            .attr('stroke', '#d63384')
            .attr('stroke-width', 4)
            .attr('stroke-opacity', 0.9)
            .attr('marker-end', 'url(#arrowhead-flow)');

        // Flow nodes
        const node = g.append('g')
            .selectAll('circle')
            .data(flowNodesForce)
            .enter()
            .append('circle')
            .attr('r', 15)
            .attr('fill', d => nodeColors[d.type] || '#999')
            .attr('stroke', '#fff')
            .attr('stroke-width', 3)
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        // Labels
        const labels = g.append('g')
            .selectAll('text')
            .data(flowNodesForce)
            .enter()
            .append('text')
            .text(d => d.name)
            .attr('font-size', 12)
            .attr('text-anchor', 'middle')
            .attr('dy', -20)
            .attr('fill', '#333')
            .attr('font-weight', 'bold')
            .style('pointer-events', 'none');

        // Tooltips
        node.append('title')
            .text(d => `${d.type}: ${d.name}\n${d.description}`);

        link.append('title')
            .text(d => `Flow: ${d.source.name || d.source.id} → ${d.target.name || d.target.id}`);

        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);

            labels
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }

    // Layout algorithms
    function createTreeLayout(svg, g, data, width, height, viewType) {
        const nodes = data.nodes.map(d => ({
            id: d.uuid,
            name: d.Name || d.uuid?.substring(0, 8) || 'Unknown',
            type: d.type,
            description: d.Descr || ''
        }));

        const links = data.relationships.filter(rel => {
            return nodes.some(n => n.id === rel.source) && nodes.some(n => n.id === rel.target);
        }).map(d => ({
            source: d.source,
            target: d.target,
            type: d.type
        }));

        // Build hierarchy for tree layout
        const rootNodes = nodes.filter(n => {
            return !data.relationships.some(rel => 
                rel.target === n.id && rel.type === 'compose'
            );
        });

        if (rootNodes.length === 0) {
            // Fallback to force layout if no clear hierarchy
            createForceLayout(svg, g, { nodes, relationships: data.relationships }, width, height, viewType);
            return;
        }

        const root = rootNodes[0];
        const hierarchy = buildHierarchy(root, nodes, data.relationships);
        
        const treeLayout = d3.tree().size([width - 100, height - 100]);
        const treeData = treeLayout(d3.hierarchy(hierarchy));

        const nodeColors = getNodeColors(viewType);
        const linkColors = getLinkColors();

        // Draw tree links
        g.selectAll('.link')
            .data(treeData.links())
            .enter()
            .append('path')
            .attr('class', 'link')
            .attr('d', d3.linkVertical()
                .x(d => d.x + 50)
                .y(d => d.y + 50))
            .attr('fill', 'none')
            .attr('stroke', '#ccc')
            .attr('stroke-width', 2);

        // Draw tree nodes
        const node = g.selectAll('.node')
            .data(treeData.descendants())
            .enter()
            .append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${d.x + 50},${d.y + 50})`);

        node.append('circle')
            .attr('r', 10)
            .attr('fill', d => nodeColors[d.data.type] || '#999')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);

        node.append('text')
            .attr('dy', -15)
            .attr('text-anchor', 'middle')
            .text(d => d.data.name)
            .attr('font-size', 10)
            .attr('fill', '#333');

        node.append('title')
            .text(d => `${d.data.type}: ${d.data.name}\\n${d.data.description}`);
    }

    function createClusterLayout(svg, g, data, width, height, viewType) {
        const nodes = data.nodes.map(d => ({
            id: d.uuid,
            name: d.Name || d.uuid?.substring(0, 8) || 'Unknown',
            type: d.type,
            description: d.Descr || ''
        }));

        // Group nodes by type for clustering
        const clusters = d3.group(nodes, d => d.type);
        const nodeColors = getNodeColors(viewType);
        
        const simulation = d3.forceSimulation(nodes)
            .force('charge', d3.forceManyBody().strength(-200))
            .force('center', d3.forceCenter(width/2, height/2))
            .force('collision', d3.forceCollide().radius(30));

        // Add cluster forces
        let i = 0;
        for (const [type, typeNodes] of clusters) {
            const angle = (i / clusters.size) * 2 * Math.PI;
            const clusterX = width/2 + Math.cos(angle) * 150;
            const clusterY = height/2 + Math.sin(angle) * 150;
            
            simulation.force(`cluster-${type}`, d3.forceX(clusterX).strength(0.3));
            simulation.force(`cluster-${type}-y`, d3.forceY(clusterY).strength(0.3));
            i++;
        }

        const node = g.append('g')
            .selectAll('circle')
            .data(nodes)
            .enter()
            .append('circle')
            .attr('r', 15)
            .attr('fill', d => nodeColors[d.type] || '#999')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .call(d3.drag()
                .on('start', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x; d.fy = d.y;
                })
                .on('drag', (event, d) => {
                    d.fx = event.x; d.fy = event.y;
                })
                .on('end', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null; d.fy = null;
                }));

        const labels = g.append('g')
            .selectAll('text')
            .data(nodes)
            .enter()
            .append('text')
            .text(d => d.name)
            .attr('font-size', 10)
            .attr('text-anchor', 'middle')
            .attr('dy', -20)
            .attr('fill', '#333')
            .style('pointer-events', 'none');

        node.append('title')
            .text(d => `${d.type}: ${d.name}\\n${d.description}`);

        simulation.on('tick', () => {
            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
            labels
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });
    }

    function createPartitionLayout(svg, g, data, width, height, viewType) {
        const nodes = data.nodes.map(d => ({
            id: d.uuid,
            name: d.Name || d.uuid?.substring(0, 8) || 'Unknown',
            type: d.type,
            description: d.Descr || '',
            value: 1
        }));

        // Build hierarchy for partition
        const rootNodes = nodes.filter(n => {
            return !data.relationships.some(rel => 
                rel.target === n.id && rel.type === 'compose'
            );
        });

        if (rootNodes.length === 0) {
            // Fallback if no hierarchy
            createForceLayout(svg, g, { nodes, relationships: data.relationships }, width, height, viewType);
            return;
        }

        const root = rootNodes[0];
        const hierarchy = buildHierarchy(root, nodes, data.relationships);
        
        const partition = d3.partition()
            .size([width, height])
            .padding(2);

        const rootHierarchy = d3.hierarchy(hierarchy)
            .sum(d => d.value || 1)
            .sort((a, b) => (b.value || 0) - (a.value || 0));

        partition(rootHierarchy);
        const nodeColors = getNodeColors(viewType);

        const cell = g.selectAll('g')
            .data(rootHierarchy.descendants())
            .enter()
            .append('g');

        cell.append('rect')
            .attr('x', d => d.x0)
            .attr('y', d => d.y0)
            .attr('width', d => d.x1 - d.x0)
            .attr('height', d => d.y1 - d.y0)
            .attr('fill', d => nodeColors[d.data.type] || '#ccc')
            .attr('stroke', '#fff')
            .attr('stroke-width', 1);

        cell.append('text')
            .attr('x', d => (d.x0 + d.x1) / 2)
            .attr('y', d => (d.y0 + d.y1) / 2)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .text(d => d.data.name || d.data.id)
            .attr('font-size', 10)
            .attr('fill', '#333')
            .style('pointer-events', 'none');

        cell.append('title')
            .text(d => d.data.type ? `${d.data.type}: ${d.data.name}\\n${d.data.description}` : d.data.id);
    }

    function createSankeyLayout(svg, g, data, width, height, viewType) {
        const nodesByType = d3.group(data.nodes, d => d.type);
        const types = viewType === 'flow' ? ['FUNC', 'ACTOR'] : ['SYS', 'MOD', 'FUNC', 'ACTOR'];
        const nodeColors = getNodeColors(viewType);

        const columnWidth = width / types.length;
        const nodePositions = new Map();
        
        types.forEach((type, typeIndex) => {
            const typeNodes = nodesByType.get(type) || [];
            const nodeHeight = height / Math.max(typeNodes.length, 1);
            
            typeNodes.forEach((node, nodeIndex) => {
                const x = typeIndex * columnWidth + columnWidth / 2;
                const y = nodeIndex * nodeHeight + nodeHeight / 2;
                
                g.append('rect')
                    .attr('x', x - 60)
                    .attr('y', y - 20)
                    .attr('width', 120)
                    .attr('height', 40)
                    .attr('fill', nodeColors[type])
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2)
                    .attr('rx', 8);
                
                g.append('text')
                    .attr('x', x)
                    .attr('y', y)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .text(node.Name || node.uuid?.substring(0, 12) || 'Unknown')
                    .attr('font-size', 9)
                    .attr('fill', '#fff')
                    .attr('font-weight', 'bold')
                    .style('pointer-events', 'none');
                
                nodePositions.set(node.uuid, { x, y });
            });
        });

        // Draw flow connections
        data.relationships.forEach(rel => {
            const sourcePos = nodePositions.get(rel.source);
            const targetPos = nodePositions.get(rel.target);
            
            if (sourcePos && targetPos) {
                const path = d3.path();
                path.moveTo(sourcePos.x + 60, sourcePos.y);
                const midX = (sourcePos.x + targetPos.x) / 2;
                path.bezierCurveTo(
                    midX, sourcePos.y,
                    midX, targetPos.y,
                    targetPos.x - 60, targetPos.y
                );
                
                g.append('path')
                    .attr('d', path.toString())
                    .attr('fill', 'none')
                    .attr('stroke', getLinkColors()[rel.type] || '#999')
                    .attr('stroke-width', 3)
                    .attr('stroke-opacity', 0.6)
                    .append('title')
                    .text(`${rel.type}: ${rel.source} → ${rel.target}`);
            }
        });
    }

    function createForceLayout(svg, g, data, width, height, viewType) {
        // This is a fallback force layout when other layouts can't be applied
        const nodes = data.nodes || data.relationships.map(d => ({ id: d.source, type: 'UNKNOWN' }));
        const links = data.relationships || [];
        
        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width/2, height/2));

        const nodeColors = getNodeColors(viewType);
        const linkColors = getLinkColors();

        const link = g.append('g')
            .selectAll('line')
            .data(links)
            .enter()
            .append('line')
            .attr('stroke', d => linkColors[d.type] || '#999')
            .attr('stroke-width', 2);

        const node = g.append('g')
            .selectAll('circle')
            .data(nodes)
            .enter()
            .append('circle')
            .attr('r', 10)
            .attr('fill', d => nodeColors[d.type] || '#999')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);

        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
        });
    }

    // Helper functions
    function buildHierarchy(root, nodes, relationships) {
        const nodeMap = new Map(nodes.map(n => [n.id, { ...n, children: [] }]));
        
        relationships.filter(rel => rel.type === 'compose').forEach(rel => {
            const parent = nodeMap.get(rel.source);
            const child = nodeMap.get(rel.target);
            if (parent && child) {
                parent.children.push(child);
            }
        });
        
        return nodeMap.get(root.id) || root;
    }

    function getNodeColors(viewType) {
        if (viewType === 'flow') {
            return {
                FUNC: '#0dcaf0',
                ACTOR: '#198754'
            };
        }
        return {
            SYS: '#dc3545',
            MOD: '#20c997',
            FUNC: '#0dcaf0',
            ACTOR: '#198754'
        };
    }

    function getLinkColors() {
        return {
            compose: '#0d6efd',
            call: '#fd7e14',
            use: '#198754',
            flow: '#d63384',
            allocate: '#6f42c1'
        };
    }
</script>
{% endblock %}